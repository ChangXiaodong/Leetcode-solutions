# 二分查找总结

二分查找总体可以分为两类：

## 以index为搜索空间的二分查找：

[153. Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/#/description)

能够以index为搜索空间的前提是数组时要经过排序的，如果没有排序则需要以range为搜索空间

## 以range为搜索空间的二分查找：

[287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/#/description)

搜索空间：low为最小数，high为最大数，计算出middle

遍历数组，统计出小于middle的个数，如果这个数大于数组长度的一半，则说明重复的数字在小于middle那边，否则在大于middle那边

[378. Kth Smallest Element in a Sorted Matrix](https://leetcode.com/problems/find-the-duplicate-number/#/description)

矩阵行按升序排列，列按升序排列，但是行和列之间没有顺序，因此二叉搜索空间为range

搜索空间：low为左上角的数，high为右下角的数

遍历矩阵每一行，统计出大于middle的个数cnt

如果cnt比k小，则说明第k小的值在大于middle的那部分，否则在小于middle的那部分





## 循环条件

### lower_bound

给定长度为 n 的单调不下降数列 a0,a1,…,an−1和一个数k,求满足ai≥k条件的最小的i.不存在的情况下输出 n。
满足“二分值越大越容易满足条件”，等同于“最小化最大值”，参见下方描述。

### upper_bound

给定长度为n的单调不下降数列a0,a1,…,an−1和一个数k,求满足ai>k条件的最小的i。不存在的情况下输出 n。

满足“二分值越大越容易满足条件”，等同于“最小化最大值”，参见下方描述。

### 最大化最小值

此种题目一般是“二分值越小越容易满足条件”，然后求符合条件的最大值。

```
#计算区间为[low, high]
while high > low:  #区间长度为1时终止循环
	#防止溢出
	mid = low + (right - low + 1) // 2		#向上取整
	if nums[mid] == target:
		low = mid
	else:
		high = mid - 1
#跳出循环时  low == high

#计算区间为[low, high)
while high > low + 1:
	mid = low + (high - low) // 2   #向下取整
	if nums[mid] == target:
		low = mid
	else:
		high = mid
#跳出循环时low + 1 == high
#答案为 low
	
	
```