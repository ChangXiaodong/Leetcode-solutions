# 二分查找总结

二分查找总体可以分为两类：

## 以index为搜索空间的二分查找：

[153. Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/#/description)

能够以index为搜索空间的前提是数组时要经过排序的，如果没有排序则需要以range为搜索空间

## 以range为搜索空间的二分查找：

[287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/#/description)

搜索空间：low为最小数，high为最大数，计算出middle

遍历数组，统计出小于middle的个数，如果这个数大于数组长度的一半，则说明重复的数字在小于middle那边，否则在大于middle那边

[378. Kth Smallest Element in a Sorted Matrix](https://leetcode.com/problems/find-the-duplicate-number/#/description)

矩阵行按升序排列，列按升序排列，但是行和列之间没有顺序，因此二叉搜索空间为range

搜索空间：low为左上角的数，high为右下角的数

遍历矩阵每一行，统计出大于middle的个数cnt

如果cnt比k小，则说明第k小的值在大于middle的那部分，否则在小于middle的那部分





## 循环条件
1. 在一个无重复的数组里，查找某个数的下标，没有返回-1
```
def binarySearch(nums, target):
   	if not nums:
   		return -1
	low = 0
   	high = nums.__len__() - 1
   	while low <= high:
   		mid = low + (high - low) >> 1
   		if nums[mid] == target:
   			return mid
   		elif nums[mid] < target:
   			low = mid + 1
   		else:
   			high = mid - 1
   	return -1
```
2. 查找第一个大于等于某个数的下标
```
def binarySearch(nums, target):
	low = 0／／
	high = nums.__len__() - 1
	while low <= high:
		mid = low + (high - low) >> 1
		if nums[mid] < target:
			low = mid + 1
		else:
			high = mid - 1
	return low if low < nums.__len__() else -1
```